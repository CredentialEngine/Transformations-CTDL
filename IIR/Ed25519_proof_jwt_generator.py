#!/usr/bin/env python3
"""
Proof JWT generator (EdDSA/Ed25519)

Behavior:
- Reads challenge JSON from file (generated by CE)
- Challenge JSON must include: did, challenge, aud, iat, exp
  - did: verification method id / DID URL with fragment; used as JWT header "kid"
- Signs payload using Ed25519 (alg=EdDSA)
- Payload is signed as-is (no changes)
"""

import argparse
import json
import sys
from typing import Any, Dict, Tuple

import base58
import jwt
from cryptography.hazmat.primitives.asymmetric.ed25519 import Ed25519PrivateKey


# -------------------------
# Multibase + multicodec helpers
# -------------------------

def parse_uvarint(data: bytes) -> Tuple[int, int]:
    x = 0
    s = 0
    for i, b in enumerate(data):
        x |= (b & 0x7F) << s
        if (b & 0x80) == 0:
            return x, i + 1
        s += 7
    raise ValueError("Invalid varint")


def decode_multibase_base58btc(z_value: str) -> bytes:
    if not z_value.startswith("z"):
        raise ValueError("Expected multibase base58btc string starting with 'z'")
    return base58.b58decode(z_value[1:])


# -------------------------
# Private key (multibase) -> Ed25519 seed
# -------------------------

def extract_ed25519_seed_from_privateKey(private_key_multibase: str) -> bytes:
    raw = decode_multibase_base58btc(private_key_multibase.strip())

    # Common encodings
    if len(raw) == 32:
        return raw
    if len(raw) == 33 and raw[0] == 0x00:
        return raw[1:]
    if len(raw) == 34 and raw[0] == 0x00 and raw[1] == 0x20:
        return raw[2:]

    # Multicodec-wrapped: varint code then 32 seed bytes
    code, n = parse_uvarint(raw)
    if code == 0x1300 and len(raw) - n == 32:
        return raw[n:]

    raise ValueError("Unrecognized privateKey encoding")


# -------------------------
# Signing
# -------------------------

def sign_payload(privateKey: str, kid: str, payload_obj: Dict[str, Any]) -> str:
    seed = extract_ed25519_seed_from_privateKey(privateKey)
    private_key = Ed25519PrivateKey.from_private_bytes(seed)

    headers = {"typ": "JWT", "alg": "EdDSA", "kid": kid}

    token = jwt.encode(
        payload=payload_obj,
        key=private_key,
        algorithm="EdDSA",
        headers=headers,
    )

    if isinstance(token, bytes):
        token = token.decode("utf-8")

    return token


# -------------------------
# CLI
# -------------------------

def main() -> int:
    ap = argparse.ArgumentParser(
        description="Sign a CE-generated challenge JSON file as a Proof JWT (verification removed)."
    )

    ap.add_argument("--privateKey", required=True, help="Ed25519 private seed (multibase base58btc, starts with 'z')")
    ap.add_argument("--challengeFile", required=True, help="Path to CE-generated challenge JSON file")
    ap.add_argument("--out", default=None)

    args = ap.parse_args()

    with open(args.challengeFile, "r", encoding="utf-8") as f:
        payload_obj = json.load(f)

    if not isinstance(payload_obj, dict):
        raise SystemExit("Challenge payload must be a JSON object.")

    # Required fields
    required_fields = ["did", "challenge", "aud", "iat", "exp"]
    missing = [k for k in required_fields if k not in payload_obj]
    if missing:
        raise SystemExit(f"Challenge JSON missing required field(s): {', '.join(missing)}")

    did_value = payload_obj.get("did")
    if not isinstance(did_value, str) or not did_value.strip():
        raise SystemExit('Challenge JSON must include a non-empty string field "did".')

    # "did" is the verification method id used as kid
    kid = did_value.strip()

    token = sign_payload(privateKey=args.privateKey, kid=kid, payload_obj=payload_obj)

    if args.out:
        with open(args.out, "w", encoding="utf-8") as f:
            f.write(token)
        print(f"Wrote Proof JWT to: {args.out}", file=sys.stderr)
    else:
        print(token)

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
