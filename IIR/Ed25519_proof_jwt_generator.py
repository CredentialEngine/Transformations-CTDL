#!/usr/bin/env python3
"""
Proof JWT generator + verifier (EdDSA/Ed25519)

Behavior:
- Reads challenge JSON from file (generated by CE)
- Challenge JSON must include: did, challenge, aud, iat, exp
  - did: verification method id / DID URL with fragment; used as JWT header "kid"
- Signs payload using Ed25519 (alg=EdDSA)
- Verifies JWT signature using public key resolved from:
  - did:key (derived from the DID)
  - did:web (fetches did.json over HTTPS using OS trust store)
"""

import argparse
import json
import sys
from typing import Any, Dict, Tuple
from urllib.parse import urljoin

import base58
import jwt
import requests
import truststore
from cryptography.hazmat.primitives.asymmetric.ed25519 import (
    Ed25519PrivateKey,
    Ed25519PublicKey,
)

# Use Windows OS certificate store
truststore.inject_into_ssl()


# -------------------------
# Multibase + multicodec helpers
# -------------------------

def parse_uvarint(data: bytes) -> Tuple[int, int]:
    x = 0
    s = 0
    for i, b in enumerate(data):
        x |= (b & 0x7F) << s
        if (b & 0x80) == 0:
            return x, i + 1
        s += 7
    raise ValueError("Invalid varint")


def decode_multibase_base58btc(z_value: str) -> bytes:
    if not z_value.startswith("z"):
        raise ValueError("Expected multibase base58btc string starting with 'z'")
    return base58.b58decode(z_value[1:])


# -------------------------
# Private key -> Ed25519 seed
# -------------------------

def extract_ed25519_seed_from_privateKey(private_key_multibase: str) -> bytes:
    raw = decode_multibase_base58btc(private_key_multibase.strip())

    if len(raw) == 32:
        return raw
    if len(raw) == 33 and raw[0] == 0x00:
        return raw[1:]
    if len(raw) == 34 and raw[0] == 0x00 and raw[1] == 0x20:
        return raw[2:]

    code, n = parse_uvarint(raw)
    if code == 0x1300 and len(raw) - n == 32:
        return raw[n:]

    raise ValueError("Unrecognized privateKey encoding")


# -------------------------
# did:key resolution (offline)
# -------------------------

def extract_ed25519_pub_from_did_key(did_or_kid: str) -> bytes:
    base = did_or_kid.split("#", 1)[0].strip()
    if not base.startswith("did:key:"):
        raise ValueError("Not a did:key DID")

    mb = base[len("did:key:"):]
    raw = decode_multibase_base58btc(mb)

    if len(raw) == 32:
        return raw

    code, n = parse_uvarint(raw)
    if code == 0xED and (len(raw) - n) == 32:
        return raw[n:]

    raise ValueError("Invalid did:key encoding")


# -------------------------
# did:web resolution (HTTPS using OS trust)
# -------------------------

def did_web_to_url(did_web: str) -> str:
    if not did_web.startswith("did:web:"):
        raise ValueError("Not a did:web DID")

    method_specific = did_web[len("did:web:"):]
    parts = method_specific.split(":")
    host = parts[0]
    path_parts = parts[1:]

    if not path_parts:
        return f"https://{host}/.well-known/did.json"

    return f"https://{host}/{'/'.join(path_parts)}/did.json"


def fetch_did_json(did_web_base: str) -> Dict[str, Any]:
    url = did_web_to_url(did_web_base)

    r = requests.get(
        url,
        headers={"Accept": "application/did+json, application/json"},
        timeout=15,
    )
    r.raise_for_status()

    doc = r.json()
    if not isinstance(doc, dict):
        raise ValueError("did.json must be a JSON object")

    return doc


def public_key_from_did_doc(*, kid: str, did_doc: Dict[str, Any]) -> bytes:
    did_base = kid.split("#", 1)[0].strip()
    kid = kid.strip()

    vms = did_doc.get("verificationMethod", [])
    if not isinstance(vms, list):
        raise ValueError("verificationMethod must be a list")

    def normalize(vm_id: str) -> str:
        return did_base + vm_id if vm_id.startswith("#") else vm_id

    for vm in vms:
        if not isinstance(vm, dict):
            continue
        vm_id = vm.get("id")
        if not isinstance(vm_id, str):
            continue

        if normalize(vm_id) != kid:
            continue

        pkmb = vm.get("publicKeyMultibase")
        if not isinstance(pkmb, str) or not pkmb.startswith("z"):
            raise ValueError("Invalid publicKeyMultibase")

        raw = decode_multibase_base58btc(pkmb)

        if len(raw) == 32:
            return raw

        code, n = parse_uvarint(raw)
        if code == 0xED and (len(raw) - n) == 32:
            return raw[n:]

        raise ValueError("Not an Ed25519 key")

    raise ValueError(f"kid not found in did.json: {kid}")


def resolve_public_key_bytes_for_kid(kid: str) -> bytes:
    base = kid.split("#", 1)[0].strip()

    if base.startswith("did:key:"):
        return extract_ed25519_pub_from_did_key(kid)

    if base.startswith("did:web:"):
        did_doc = fetch_did_json(base)
        return public_key_from_did_doc(kid=kid, did_doc=did_doc)

    raise ValueError(f"Unsupported DID method: {base}")


# -------------------------
# Signing + verification
# -------------------------

def sign_payload(privateKey: str, kid: str, payload_obj: Dict[str, Any]) -> str:
    seed = extract_ed25519_seed_from_privateKey(privateKey)
    private_key = Ed25519PrivateKey.from_private_bytes(seed)

    headers = {"typ": "JWT", "alg": "EdDSA", "kid": kid}

    token = jwt.encode(
        payload=payload_obj,
        key=private_key,
        algorithm="EdDSA",
        headers=headers,
    )

    if isinstance(token, bytes):
        token = token.decode("utf-8")

    return token


def verify_signature_only(token: str, public_key: Ed25519PublicKey) -> None:
    jwt.decode(
        token,
        key=public_key,
        algorithms=["EdDSA"],
        options={
            "verify_signature": True,
            "verify_aud": False,
            "verify_exp": False,
            "verify_iat": False,
            "verify_nbf": False,
            "verify_iss": False,
        },
    )


# -------------------------
# CLI
# -------------------------

def main() -> int:
    ap = argparse.ArgumentParser(description="Sign and verify Proof JWT")

    ap.add_argument("--privateKey", required=True)
    ap.add_argument("--challengeFile", required=True)
    ap.add_argument("--out", default=None)
    ap.add_argument("--noVerify", action="store_true")

    args = ap.parse_args()

    with open(args.challengeFile, "r", encoding="utf-8") as f:
        payload_obj = json.load(f)

    kid = payload_obj["did"].strip()

    token = sign_payload(args.privateKey, kid, payload_obj)

    if not args.noVerify:
        pub_bytes = resolve_public_key_bytes_for_kid(kid)
        pub_key = Ed25519PublicKey.from_public_bytes(pub_bytes)
        verify_signature_only(token, pub_key)
        print("Signature verification: OK", file=sys.stderr)

    if args.out:
        with open(args.out, "w", encoding="utf-8") as f:
            f.write(token)
    else:
        print(token)

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
